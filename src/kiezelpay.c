/*
* KiezelPay Integration Library - v1.4 - Copyright Kiezel 2016
*
* BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO 
* WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE 
* LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT 
* HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY "AS IS" 
* WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
* INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
* RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU.
* SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL 
* NECESSARY SERVICING, REPAIR OR CORRECTION.
* 
* IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN 
* WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY 
* MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE 
* LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, 
* INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR 
* INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS
* OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY 
* YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH
* ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN 
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
*/

#include <pebble.h>
#include "kiezelpay.h"

#if KIEZELPAY_LOG_VERBOSE
#define LOG(...) APP_LOG(APP_LOG_LEVEL_DEBUG, __VA_ARGS__)
#else
#define LOG(...)
#endif

//storage keys
#define KIEZELPAY_STORAGE_KEY_STATE 119526512
#define KIEZELPAY_STORAGE_KEY_STATE_HASH 119526513
#define KIEZELPAY_STORAGE_KEY_STATE_VERSION 119526514

//uint32_t generated by KiezelPay server on download of this library; identifies the app on the server
#define KIEZELPAY_APP_ID_VALUE 1400043768

static uint8_t kiezelpay_secret[16] = {182, 198, 172, 169, 1, 24, 57, 184, 222, 80, 126, 192, 115, 80, 51, 145};

#define KIEZELPAY_INPUT_BUFFER_SIZE dict_calc_buffer_size(5, 4, 4, 4, 4, 32)
#define KIEZELPAY_OUTPUT_BUFFER_SIZE dict_calc_buffer_size(4, 4, 4, 4, 4)

#define KIEZELPAY_STATUS_CHECK_INTERVAL 2000
#define KIEZELPAY_FAILSAFE_STATUS_CHECK_INTERVAL 15000
#define KIEZELPAY_INTERNET_FAILURES_THRESHOLD 2
#define KIEZELPAY_BLUETOOTH_FAILURES_THRESHOLD 5
#define KIEZELPAY_GENERIC_ERRORS_THRESHOLD 5
#define KIEZELPAY_STATUS_REQUESTS_WITHOUT_RESPONSE_THRESHOLD 3

#define SHA256_BLOCK_SIZE 32

typedef struct {
  bool kiezelpay_purchase_in_progress:1;
  bool kiezelpay_purchase_started:1;
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  bool kiezelpay_expired_status_recheck_in_progress:1;
#endif
  bool kiezelpay_status_checking_finished:1;
  uint8_t kiezelpay_internet_failures:2;                       //never more then 2
  uint8_t kiezelpay_bt_failures:3;                             //never more then 5
  uint8_t kiezelpay_generic_errors:3;                          //never more then 5
  uint8_t kiezelpay_status_requests_without_response:4;        //never more then 10
} kiezelpay_flags_t;

static kiezelpay_flags_t kiezelpay_flags = {
  .kiezelpay_purchase_in_progress = false,
  .kiezelpay_purchase_started = false,
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  .kiezelpay_expired_status_recheck_in_progress = false,
#endif
  .kiezelpay_status_checking_finished = false,
  .kiezelpay_bt_failures = 0,
  .kiezelpay_internet_failures = 0,
  .kiezelpay_generic_errors = 0
};

/**
  KiezelPay AppMessage types
*/
typedef enum {
  KIEZELPAY_STATUS_MSG,        /**< Status msg received from server telling us the current status for this app */
  KIEZELPAY_NO_INTERNET_MSG,   /**< Cannot reach KiezelPay server */
  KIEZELPAY_READY_MSG          /**< PebbleKitJS is ready */
} kiezelpay_msg_type;

/**
  KiezelPay incoming AppMessage representation
*/
typedef struct {
  kiezelpay_msg_type msg_type;
  uint8_t purchase_status:1;   /**< 0 waitForUser, 1 inProgress */
  uint8_t status:2;            /**< 0 unlicensed, 1 in trial, 2 licensed */
  uint32_t purchase_code:17;   /**< 17 bits is enough, code has max value of 99999 and 17 bits can hold up to 131071  */
  uint8_t *checksum;           /**< checksum generated by server for this message */
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
  uint32_t trial_duration;     /**< expressed in seconds */
#endif
  uint8_t validity_period;     /**< expressed in full days (86400 seconds) */
} kiezelpay_msg_data;

/**
  KiezelPay current state representation
*/
typedef struct {
  bool licensed:1;
  bool trial_ended:1;
  bool trial_started:1;
  time_t trial_end_time;
  uint32_t device_id;
  time_t expiration_time;    /**< when this state expires and should be rechecked on the KiezelPay server */
}__attribute__((__packed__)) kiezelpay_state;
#define KIEZELPAY_STATE_VERSION 1


static uint16_t kiezelpay_msg_random = 0;
static kiezelpay_event last_event = KIEZELPAY_NO_EVENT;

static AppTimer *kiezelpay_check_timer = NULL;
static AppTimer *kiezelpay_failsafe_check_timer = NULL;
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
static AppTimer *kiezelpay_trial_end_timer = NULL;
#endif
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
static AppTimer *kiezelpay_status_expired_timer = NULL;
#endif

//default settings
kiezelpay_config kiezelpay_settings = {
  .messaging_inbox_size = 0,
  .messaging_outbox_size = 0,
  .on_kiezelpay_event = NULL,
  .on_inbox_received = NULL,
  .on_inbox_dropped = NULL,
  .on_outbox_failed = NULL,
  .on_outbox_sent = NULL
};

//KiezelPay AppMessage keys
enum {
  KIEZELPAY_READY = 119526512,
  KIEZELPAY_STATUS_CHECK = 119526513,
  KIEZELPAY_APP_ID = 119526514,
  KIEZELPAY_DEVICE_TOKEN = 119526515,
  KIEZELPAY_STATUS_RESULT = 119526516,
  KIEZELPAY_STATUS_CHECKSUM = 119526517,
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
  KIEZELPAY_STATUS_TRIAL_DURATION = 119526518,
#endif
  KIEZELPAY_PURCHASE_CODE = 119526519,
  KIEZELPAY_INTERNET_FAIL = 119526520,
  KIEZELPAY_PURCHASE_STATUS = 119526521,
  KIEZELPAY_RANDOM = 119526522,
  KIEZELPAY_STATUS_VALIDITY_PERIOD = 119526523
};

//let the kiezelpay server know which settings are being used here
typedef enum {
  KIEZELPAY_STATUS_CHECK_DEFAULT = 1,
  KIEZELPAY_TEST_MODE_ENABLED    = 1 << 1,
  KIEZELPAY_TIME_TRIAL_DISABLED  = 1 << 2,
  KIEZELPAY_V1_1  = 1 << 3
} kiezelpay_status_check_flags;

bool is_new_install();
uint32_t kiezelpay_device_id();
void kiezelpay_messaging_init();
void kiezelpay_messaging_deinit();

//represents the current state of this app
static kiezelpay_state kiezelpay_current_state;

#if KIEZELPAY_TEST_MODE
static void validate_settings();
#endif

static void kiezelpay_schedule_status_check();
static void kiezelpay_failsafe_schedule_status_check(void *data);
static void kiezelpay_status_check(void *data);
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
static void kiezelpay_schedule_trial_end_timer();
static void kiezelpay_end_trial();
#endif
static bool kiezelpay_fire_event(kiezelpay_event e, void *extra_data);
static void kiezelpay_unhandled_event(kiezelpay_event e, void* extra_data);

static void kiezelpay_store_state(uint8_t validity_period);
static void kiezelpay_load_state();
static int32_t kiezelpay_get_stored_state_version();
static void kiezelpay_generate_state_hash(uint8_t* hash_buffer);
static bool kiezelpay_validate_state();

#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
static bool kiezelpay_perform_status_expired_checks();
static int32_t kiezelpay_get_state_expiration_time();
static bool kiezelpay_is_state_expired();
static void kiezelpay_schedule_status_expired_timer();
#endif

static void kiezelpay_inbox_received_handler(DictionaryIterator *iterator, void *context);
static void kiezelpay_inbox_dropped_handler(AppMessageResult reason, void *context);
static void kiezelpay_outbox_failed_handler(DictionaryIterator *iterator, AppMessageResult reason, void *context);
static void kiezelpay_outbox_sent_handler(DictionaryIterator *iterator, void *context);

static bool kiezelpay_receive_message(DictionaryIterator *iterator);
static void kiezelpay_handle_message(kiezelpay_msg_data *msg);
static void kiezelpay_handle_status_result(kiezelpay_msg_data *msg);
static bool kiezelpay_validate_msg(kiezelpay_msg_data *msg);

#if KIEZELPAY_DISABLE_MESSAGES == 0
Window *kiezelpay_alert_window = NULL;

#ifdef PBL_SDK_3
	StatusBarLayer *kiezelpay_status_bar_layer;
#else
  Layer *kiezelpay_top_bar_layer;
	TextLayer *kiezelpay_time_text_layer;
	char kiezelpay_time_text_buffer[16];
  AppTimer *kiezelpay_top_bar_timer;
#endif

TextLayer *kiezelpay_message_layer;
char *kiezelpay_message_text = NULL;
Layer *kiezelpay_bottom_bar_layer;
TextLayer *kiezelpay_bottom_text_layer;
char *kiezelpay_code_text = NULL;
bool kiezelpay_isErrorAlert = false;
static AppTimer *kiezelpay_hideMsgTimer = NULL;

#define ROUND_EXTRA_HEIGHT 50

static void kiezelpay_show_alert(const char *message, uint32_t *code, bool isError, uint32_t auto_hide_timeout_in_seconds);
static void kiezelpay_hide_alert();
static bool kiezelpay_is_error_alert_displayed();

#endif

/*********************    SHA-256 Hashing   *************************/
/* Author:     Brad Conte (brad AT bradconte.com)                   */
/* Source:     https://github.com/B-Con/crypto-algorithms/          */
/********************************************************************/

typedef struct {
	uint8_t data[64];
	uint32_t datalen;
	unsigned long long bitlen;
	uint32_t state[8];
} SHA256_CTX; 

void sha256_init(SHA256_CTX *ctx);
void sha256_update(SHA256_CTX *ctx, const uint8_t data[], size_t len);
void sha256_final(SHA256_CTX *ctx, uint8_t hash[]);
/*******************************************************************/  
 
/**
* Call once on watchface/app init before using any other functions 
*/
void kiezelpay_init() {
  LOG("%s", __func__);
  srand(time(NULL));
  
  //check if this is a new install
  bool generate_fresh_state = false;
  if (is_new_install()) {
    LOG("kiezelpay: new install");
    
    //new install, generate a new userId for this user
    generate_fresh_state = true;
  }
  else {
    if (kiezelpay_get_stored_state_version() == KIEZELPAY_STATE_VERSION) {    //check if its at the current version
      //load the state from storage
      kiezelpay_load_state();
          
      //check if it was tampered with
      if (!kiezelpay_validate_state()) {
        //this state was tampered with... revert to an unlicensed state!
        LOG("kiezelpay: app state was tampered with! reverting to unlicensed state.");
        generate_fresh_state = true;
      }
    }
	else {
      generate_fresh_state = true;
    }
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
    kiezelpay_current_state.trial_ended = false;
#endif
  }
  
  if (generate_fresh_state) {
    LOG("kiezelpay: creating new unlicensed app state");
    kiezelpay_current_state.licensed = false;
    kiezelpay_current_state.trial_ended = false;
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
    kiezelpay_current_state.trial_started = false;    
    kiezelpay_current_state.trial_end_time = 0;
#endif
    kiezelpay_current_state.device_id = rand();
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    kiezelpay_current_state.expiration_time = time(NULL);
#endif
    
    kiezelpay_store_state(0);
  }
  
#if KIEZELPAY_TEST_MODE
  //check if the settings are correct
  validate_settings();
#endif
  
  //init messaging
  kiezelpay_messaging_init();
  
  //check for startup actions
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
  if (!kiezelpay_current_state.licensed) {
    if (kiezelpay_current_state.trial_started) {
      //time based trial is running, start a timer that fires on end of trial
      kiezelpay_schedule_trial_end_timer();
    }
    else {
      //no trial running (yet), but it does have to be controlled by kiezelpay lib
      //make sure ppl cannot use our stuff for free by just disabling the "READY" javascript event, 
      //start a failsafe timer to begin status checking without that READY event as well
      kiezelpay_failsafe_check_timer = app_timer_register(KIEZELPAY_FAILSAFE_STATUS_CHECK_INTERVAL, kiezelpay_failsafe_schedule_status_check, NULL);
    }
  }
#endif
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  //schedule re-checks of the current status if needed
  kiezelpay_schedule_status_expired_timer();
#endif
}

#if KIEZELPAY_TEST_MODE
static void validate_settings() {
  //only in test mode, once its all working and set up correctly its not needed to run these checks each time in production mode
  //check that the user is catching the KiezelPay events OR we have a window available to show the messages to the user
  LOG("Checking KiezelPay settings. This is only done when KIEZELPAY_TEST_MODE is enabled.");
  
#if KIEZELPAY_DISABLE_MESSAGES
  if (kiezelpay_settings.on_kiezelpay_event == NULL) {
    LOG("SETTINGS VALIDATION ERROR: You are running the KiezelPay library in KIEZELPAY_DISABLE_MESSAGES. In this mode the KiezelPay lib will NOT display messages to the user, make sure you catch the KiezelPay event and handle the events yourself! Otherwise there will be no way to display the necesarry information to the user!");
  }
#endif
  
  //check if buffers are large enough for kiezelpay appmessages
  int min_inbox_size = KIEZELPAY_INPUT_BUFFER_SIZE;
  int min_outbox_size = KIEZELPAY_OUTPUT_BUFFER_SIZE;
  if (kiezelpay_settings.messaging_inbox_size != 0 && kiezelpay_settings.messaging_inbox_size < min_inbox_size) {
    LOG("SETTINGS VALIDATION ERROR: The inbox buffer size is set too small! The minimum size is %d. This will cause the KiezelPay AppMessages to fail!", min_inbox_size);
  }
  if (kiezelpay_settings.messaging_outbox_size != 0 && kiezelpay_settings.messaging_outbox_size < min_outbox_size) {
    LOG("SETTINGS VALIDATION ERROR: The outbox buffer size is set too small! The minimum size is %d. This will cause the KiezelPay AppMessages to fail!", min_outbox_size);
  }

#if KIEZELPAY_DISABLE_TIME_TRIAL
  LOG("SETTINGS VALIDATION WARNING: You have set the setting KIEZELPAY_DISABLE_TIME_TRIAL to 1, this means you have to signal the KiezelPay lib yourself when the trial ends by calling \"kiezelpay_start_purchase()\", or the user will be able to use your app forever for free!");
#endif
  
  LOG("Done checking KiezelPay settings. This is only done when KIEZELPAY_TEST_MODE is enabled.");
}
#endif

bool is_new_install() {
  return !persist_exists(KIEZELPAY_STORAGE_KEY_STATE);
}

int32_t kiezelpay_get_status() {
  int32_t result = KIEZELPAY_NO_EVENT;
  
  //license status (trial started/trial ended/licensed)
  if (kiezelpay_current_state.licensed) {
    result = result | KIEZELPAY_LICENSED;
  }
  else if (kiezelpay_current_state.trial_ended) {
    result = result | KIEZELPAY_TRIAL_ENDED;
  } 
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
  else if (kiezelpay_current_state.trial_started) {
    result = result | KIEZELPAY_TRIAL_STARTED;
  }
#endif
  
  //purchase status (code available, purchase started)
  if (last_event == KIEZELPAY_CODE_AVAILABLE || last_event == KIEZELPAY_PURCHASE_STARTED) {
    result = result | last_event;
  }
  
  //error status (bt, internet or generic)
  if (kiezelpay_flags.kiezelpay_bt_failures >= KIEZELPAY_BLUETOOTH_FAILURES_THRESHOLD) {
    result = result | KIEZELPAY_BLUETOOTH_UNAVAILABLE;
  }
  if (kiezelpay_flags.kiezelpay_internet_failures >= KIEZELPAY_INTERNET_FAILURES_THRESHOLD) {
    result = result | KIEZELPAY_INTERNET_UNAVAILABLE;
  }
  if (kiezelpay_flags.kiezelpay_generic_errors >= KIEZELPAY_GENERIC_ERRORS_THRESHOLD) {
    result = result | KIEZELPAY_ERROR;
  }
  
  return result;
}

static void kiezelpay_schedule_status_check(void *data) {
  LOG("%s", __func__);
  if (!kiezelpay_flags.kiezelpay_status_checking_finished) {
    if (kiezelpay_check_timer != NULL) {
      if (!app_timer_reschedule(kiezelpay_check_timer, KIEZELPAY_STATUS_CHECK_INTERVAL)) {
        kiezelpay_check_timer = app_timer_register(KIEZELPAY_STATUS_CHECK_INTERVAL, kiezelpay_status_check, data);
      }
    }
    else {
      kiezelpay_check_timer = app_timer_register(KIEZELPAY_STATUS_CHECK_INTERVAL, kiezelpay_status_check, data);
    }
  }
  else {
    LOG("kiezelpay_schedule_status_check() - checking finished");
  }
}

static void kiezelpay_failsafe_schedule_status_check(void *data) {
  LOG("%s", __func__);
  if (!kiezelpay_flags.kiezelpay_status_checking_finished) {
    //schedule status check
    kiezelpay_schedule_status_check(data);
    
    //schedule failsafe timer
    if (kiezelpay_failsafe_check_timer != NULL) {
      if (!app_timer_reschedule(kiezelpay_failsafe_check_timer, KIEZELPAY_FAILSAFE_STATUS_CHECK_INTERVAL)) {
        kiezelpay_failsafe_check_timer = app_timer_register(KIEZELPAY_FAILSAFE_STATUS_CHECK_INTERVAL, kiezelpay_failsafe_schedule_status_check, data);
      } 
    }
    else {
      kiezelpay_failsafe_check_timer = app_timer_register(KIEZELPAY_FAILSAFE_STATUS_CHECK_INTERVAL, kiezelpay_failsafe_schedule_status_check, data);
    }
  }
  else {
    LOG("kiezelpay_failsafe_schedule_status_check() - checking finished");
  }
}

#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
static void kiezelpay_end_trial_callback(void *data) {
  kiezelpay_end_trial();
}

static void kiezelpay_schedule_trial_end_timer() {
  LOG("%s", __func__);
  if (kiezelpay_trial_end_timer != NULL) {
    app_timer_cancel(kiezelpay_trial_end_timer);
    kiezelpay_trial_end_timer = NULL;
  }
  
  time_t now = time(NULL);
  if (kiezelpay_current_state.trial_ended || (kiezelpay_current_state.trial_started && now >= kiezelpay_current_state.trial_end_time)) {
    //already ended!
    kiezelpay_end_trial();
  }
  else if (kiezelpay_current_state.trial_started && now < kiezelpay_current_state.trial_end_time) {
    //start timer which ends when the trial ends
    LOG("Scheduling trial to end in %li seconds.", (kiezelpay_current_state.trial_end_time - now));
    kiezelpay_trial_end_timer = app_timer_register((kiezelpay_current_state.trial_end_time - now) * 1000, kiezelpay_end_trial_callback, NULL);
  }
}
#endif

static void kiezelpay_end_status_reached() {
  LOG("%s", __func__);
  if (kiezelpay_check_timer != NULL) {
    app_timer_cancel(kiezelpay_check_timer);
    kiezelpay_check_timer = NULL;
  }
  if (kiezelpay_failsafe_check_timer != NULL) {
    app_timer_cancel(kiezelpay_failsafe_check_timer);
    kiezelpay_failsafe_check_timer = NULL;
  }
  
  kiezelpay_flags.kiezelpay_status_checking_finished = true;
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress = false;
#endif
}

static uint32_t kiezelpay_get_status_flags() {
  //encode the "settings" of this app in the status request to let the
  //server know how it is configured and adapt itself to that if necesarry
  uint32_t status_flags = KIEZELPAY_STATUS_CHECK_DEFAULT | KIEZELPAY_V1_1;
#if KIEZELPAY_TEST_MODE
  status_flags = status_flags | KIEZELPAY_TEST_MODE_ENABLED;
#endif
#if KIEZELPAY_DISABLE_TIME_TRIAL
  status_flags = status_flags | KIEZELPAY_TIME_TRIAL_DISABLED;
#else
  if (kiezelpay_flags.kiezelpay_purchase_started) {
    //allow to force purchase eventhough trial is still in progress
    status_flags = status_flags | KIEZELPAY_TIME_TRIAL_DISABLED;
  }
#endif
  return status_flags;
}

static void kiezelpay_status_check(void *data) {
  LOG("%s", __func__);
  
  //check if a timer is running to perform a status check as well, in that case cancel it
  if (kiezelpay_check_timer != NULL) {
    app_timer_cancel(kiezelpay_check_timer);
    kiezelpay_check_timer = NULL;
  }
  
  //show that we are performing status checks
  kiezelpay_flags.kiezelpay_status_checking_finished = false;
  
  //check if our status requests reach their destination
  if (kiezelpay_flags.kiezelpay_status_requests_without_response >= KIEZELPAY_STATUS_REQUESTS_WITHOUT_RESPONSE_THRESHOLD
     #if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0      
      && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
     #endif
     ) {
    //no response from kiezelpay server on the last 10 status requests, assume internet is not available
    //fire the event
    if (!kiezelpay_fire_event(KIEZELPAY_INTERNET_UNAVAILABLE, NULL)) {
      kiezelpay_unhandled_event(KIEZELPAY_INTERNET_UNAVAILABLE, NULL);
    }
  }
	else if (kiezelpay_flags.kiezelpay_status_requests_without_response < KIEZELPAY_STATUS_REQUESTS_WITHOUT_RESPONSE_THRESHOLD 
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0      
      && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
    ) {
		//count the request we're about to send
    kiezelpay_flags.kiezelpay_status_requests_without_response++;
	}
  
  //send message requesting a status check
  DictionaryIterator *iter;
  app_message_outbox_begin(&iter);

  //we want to check the initial status for this watchface
  Tuplet statusMsgTuple = TupletInteger(KIEZELPAY_STATUS_CHECK, kiezelpay_get_status_flags());
  dict_write_tuplet(iter, &statusMsgTuple);
  
  //add our device token to identify this watch
  Tuplet deviceTokenTuple = TupletInteger(KIEZELPAY_DEVICE_TOKEN, kiezelpay_current_state.device_id);
  dict_write_tuplet(iter, &deviceTokenTuple);
  
  //add the app ID that was defined by the KP server
  Tuplet appIdTuple = TupletInteger(KIEZELPAY_APP_ID, KIEZELPAY_APP_ID_VALUE);
  dict_write_tuplet(iter, &appIdTuple);
  
  //add random number to avoid replay attacks
  if (kiezelpay_msg_random == 0) { 
    kiezelpay_msg_random = (rand() % 0xFFFF);		//limit to uint16_t
  }
  Tuplet randomTuple = TupletInteger(KIEZELPAY_RANDOM, kiezelpay_msg_random);
  dict_write_tuplet(iter, &randomTuple);
  dict_write_end(iter);
  
  //send the message!
  app_message_outbox_send();
}

void kiezelpay_start_purchase() {
  LOG("%s", __func__);
  
  if (!kiezelpay_current_state.licensed) {
    //store that the trial is over
    kiezelpay_current_state.trial_ended = true;
    kiezelpay_flags.kiezelpay_purchase_started = true;
    kiezelpay_store_state(0);
  
    //start doing status checks to initiate the purchase
    kiezelpay_flags.kiezelpay_status_checking_finished = false;
    kiezelpay_failsafe_schedule_status_check(NULL);
  }
}

void kiezelpay_cancel_purchase() {
  LOG("%s", __func__);
  
  if (!kiezelpay_current_state.licensed) {
    //store that the trial is over
    kiezelpay_current_state.trial_ended = false;
    kiezelpay_flags.kiezelpay_purchase_started = false;
    kiezelpay_store_state(0);
   
    //stop doing status checks and hide any purchase dialogs still visible
    kiezelpay_end_status_reached();
#if KIEZELPAY_DISABLE_MESSAGES == 0
    kiezelpay_hide_alert();
#endif
    
    //clear last event to make sure the purchase dialog is shown again if kiezelpay_start_purchase() is called
    last_event = KIEZELPAY_NO_EVENT;
  }
}

#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
static void kiezelpay_end_trial() {
  LOG("%s", __func__);
  
  if (!kiezelpay_current_state.licensed) {
    //store that the trial is over
    kiezelpay_current_state.trial_ended = true;
    kiezelpay_flags.kiezelpay_purchase_started = true;
    kiezelpay_store_state(0);
    
    if (!kiezelpay_fire_event(KIEZELPAY_TRIAL_ENDED, NULL)) {
      kiezelpay_unhandled_event(KIEZELPAY_TRIAL_ENDED, NULL);
    }
  
    //start doing status checks to initiate the purchase
    kiezelpay_flags.kiezelpay_status_checking_finished = false;
    kiezelpay_failsafe_schedule_status_check(NULL);
  }
}

time_t kiezelpay_get_trial_end_time() {
  return kiezelpay_current_state.trial_end_time;
}
#endif

void kiezelpay_deinit() {
  LOG("%s", __func__);
}

/**** KIEZELPAY - MESSAGING ***/
void kiezelpay_messaging_init() {
  LOG("%s", __func__);
  // Register pebble appmessage handler
  app_message_register_inbox_received(kiezelpay_inbox_received_handler);
  app_message_register_inbox_dropped(kiezelpay_inbox_dropped_handler);
  app_message_register_outbox_failed(kiezelpay_outbox_failed_handler);
  app_message_register_outbox_sent(kiezelpay_outbox_sent_handler);
  
  if (kiezelpay_settings.messaging_inbox_size == 0) {
    kiezelpay_settings.messaging_inbox_size = KIEZELPAY_INPUT_BUFFER_SIZE;
  }
  if (kiezelpay_settings.messaging_outbox_size == 0) {
    kiezelpay_settings.messaging_outbox_size = KIEZELPAY_OUTPUT_BUFFER_SIZE;
  }
  
  // Open AppMessage channel
  uint32_t inbox_size = kiezelpay_settings.messaging_inbox_size;
  uint32_t outbox_size = kiezelpay_settings.messaging_outbox_size;
  if (inbox_size > app_message_inbox_size_maximum()) {
    inbox_size = app_message_inbox_size_maximum();
  }
  if (outbox_size > app_message_outbox_size_maximum()) {
    outbox_size = app_message_outbox_size_maximum();
  }
  LOG("Kiezelpay AppMessage inbox size: %lu", (unsigned long)inbox_size);
  LOG("Kiezelpay AppMessage outbox size: %lu", (unsigned long)outbox_size);
  app_message_open(inbox_size, outbox_size);
}

void kiezelpay_messaging_deinit() {
  LOG("%s", __func__);
  app_message_deregister_callbacks();
}

static void kiezelpay_inbox_received_handler(DictionaryIterator *iterator, void *context) {
  LOG("%s", __func__);
  
  //check if this message is for kiezelpay
  if (!kiezelpay_receive_message(iterator)) {
    //not a kiezelpay message, forward call to anyone interested
    if (kiezelpay_settings.on_inbox_received != NULL) {
      kiezelpay_settings.on_inbox_received(iterator, context);
    }
  }
}

static bool is_kiezelpay_message(DictionaryIterator *iterator) {
  Tuple *t = dict_read_first(iterator);
  
  while(t != NULL) {
    switch (t->key) {
      case KIEZELPAY_READY:
      case KIEZELPAY_DEVICE_TOKEN:
      case KIEZELPAY_STATUS_CHECK:
      case KIEZELPAY_STATUS_RESULT:
      case KIEZELPAY_STATUS_CHECKSUM:
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
      case KIEZELPAY_STATUS_TRIAL_DURATION:
#endif
      case KIEZELPAY_PURCHASE_CODE:
      case KIEZELPAY_PURCHASE_STATUS:
      case KIEZELPAY_INTERNET_FAIL:
      case KIEZELPAY_STATUS_VALIDITY_PERIOD:
        return true;
    }
    
    t = dict_read_next(iterator);
  }
  
  return false;
}

static bool kiezelpay_receive_message(DictionaryIterator *iterator) {
  LOG("%s", __func__);
  Tuple *t = dict_read_first(iterator);
  
  bool kiezel_keys_found = false;
  kiezelpay_msg_data received_data = {
    .checksum = NULL
  };
  
  while(t != NULL) {
    switch (t->key) {
      case KIEZELPAY_READY:
        kiezel_keys_found = true;
        received_data.msg_type = KIEZELPAY_READY_MSG;
        break;
      case KIEZELPAY_STATUS_RESULT:
        kiezel_keys_found = true;
        received_data.msg_type = KIEZELPAY_STATUS_MSG;
        received_data.status = t->value->int8;
        break;
      case KIEZELPAY_PURCHASE_STATUS:
        kiezel_keys_found = true;
        received_data.purchase_status = t->value->int8;
        break;
      case KIEZELPAY_STATUS_VALIDITY_PERIOD:
        kiezel_keys_found = true;
        received_data.validity_period = t->value->int8;
        break;
      case KIEZELPAY_STATUS_CHECKSUM:
        kiezel_keys_found = true;
        received_data.checksum = t->value->data;
        break;
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
      case KIEZELPAY_STATUS_TRIAL_DURATION:
        kiezel_keys_found = true;
        received_data.trial_duration = t->value->int32;
        break;
#endif
      case KIEZELPAY_PURCHASE_CODE:
        kiezel_keys_found = true;
        received_data.purchase_code = t->value->int32;
        break;
      case KIEZELPAY_INTERNET_FAIL:
        kiezel_keys_found = true;
        received_data.msg_type = KIEZELPAY_NO_INTERNET_MSG;
        break;
    }
    
    t = dict_read_next(iterator);
  }
  
  if (kiezel_keys_found) {
    kiezelpay_handle_message(&received_data);
  }
  
  return kiezel_keys_found;
}

static void kiezelpay_handle_message(kiezelpay_msg_data *msg) {
  LOG("%s", __func__);
  if (msg->msg_type == KIEZELPAY_READY_MSG) {
#if KIEZELPAY_DISABLE_TIME_TRIAL
    //determine the initial status of this app at startup (fresh install, in trial, trial ended, licensed)
    if (!kiezelpay_current_state.licensed) {
#else
    if ((!kiezelpay_current_state.trial_started || kiezelpay_current_state.trial_ended) && !kiezelpay_current_state.licensed) {
#endif
      //this app has a time based trial managed by the kiezelpay server, we can perform a status check without starting an unwanted purchase
      //OR the developer has already signaled us that the trial has ended
      //AND is not licensed yet, so start performing status checks to initiate/resume the purchase
      LOG("kiezelpay ready msg received; starting status checks");
      kiezelpay_status_check(NULL);    //start checking for status of this app
      //make sure the failsafe kicks in after 15 seconds if the initial check fails
      kiezelpay_failsafe_check_timer = app_timer_register(KIEZELPAY_FAILSAFE_STATUS_CHECK_INTERVAL, kiezelpay_failsafe_schedule_status_check, NULL);
    }
    else {
      LOG("kiezelpay ready msg received; no action necesarry");
    }
  }
  
  if (msg->msg_type == KIEZELPAY_NO_INTERNET_MSG) {
    LOG("kiezelpay no internet msg received");
    if (kiezelpay_flags.kiezelpay_internet_failures >= KIEZELPAY_INTERNET_FAILURES_THRESHOLD
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
        && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
       ) {     
      //fire the event
      if (!kiezelpay_fire_event(KIEZELPAY_INTERNET_UNAVAILABLE, NULL)) {
        kiezelpay_unhandled_event(KIEZELPAY_INTERNET_UNAVAILABLE, NULL);
      }
    }
  	else if (kiezelpay_flags.kiezelpay_internet_failures < KIEZELPAY_INTERNET_FAILURES_THRESHOLD 
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0      
      && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
    ) {
  		kiezelpay_flags.kiezelpay_internet_failures++;
  	}
    
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    if (kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress) {
      //stop periodic rechecks after one attempt
      kiezelpay_end_status_reached();
      
      //schedule to try again in one day
      kiezelpay_store_state(1);
    }
    else {
#endif
      //schedule another status check to try again untill we have internet again
      kiezelpay_failsafe_schedule_status_check(NULL);
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    }
#endif
  }
  
  if (msg->msg_type == KIEZELPAY_STATUS_MSG) {
    #if KIEZELPAY_DISABLE_MESSAGES == 0
    if ((kiezelpay_flags.kiezelpay_internet_failures >= KIEZELPAY_INTERNET_FAILURES_THRESHOLD ||
        kiezelpay_flags.kiezelpay_status_requests_without_response >= KIEZELPAY_STATUS_REQUESTS_WITHOUT_RESPONSE_THRESHOLD) && 
        kiezelpay_is_error_alert_displayed()) {
      kiezelpay_hide_alert();    //hide any alert that might have been shown before
    }
    #endif
    kiezelpay_flags.kiezelpay_internet_failures = 0;
    kiezelpay_flags.kiezelpay_status_requests_without_response = 0;
    kiezelpay_handle_status_result(msg);
  }
}

static void kiezelpay_generic_error_occurred() {
  LOG("%s", __func__);
  if (kiezelpay_flags.kiezelpay_generic_errors >= KIEZELPAY_GENERIC_ERRORS_THRESHOLD 
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0      
      && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
     ) {
    //fire the event
    if (!kiezelpay_fire_event(KIEZELPAY_ERROR, NULL)) {
      //was not handled by user, so handle it ourselves
      kiezelpay_unhandled_event(KIEZELPAY_ERROR, NULL);
    }
  }
  else if (kiezelpay_flags.kiezelpay_generic_errors < KIEZELPAY_GENERIC_ERRORS_THRESHOLD 
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0      
      && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
    ) {
	  kiezelpay_flags.kiezelpay_generic_errors++;
  }
  
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  if (kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress) {
    //stop status requests after one try when doing rechecks
    kiezelpay_end_status_reached();
    
    //reschedule to try again after one day
    kiezelpay_store_state(1);
  }
#endif
}

static void kiezelpay_handle_status_result(kiezelpay_msg_data *msg) {
  LOG("%s", __func__);
  if (!kiezelpay_validate_msg(msg)) {
    LOG("Invalid message received!");
    kiezelpay_generic_error_occurred();
    
    //try again
    kiezelpay_failsafe_schedule_status_check(NULL);
    
    //do not proceed when msg invalid
    return;
  }
  
  //message is valid and we are going to check the results
#if KIEZELPAY_DISABLE_MESSAGES == 0
  if (kiezelpay_flags.kiezelpay_generic_errors >= KIEZELPAY_GENERIC_ERRORS_THRESHOLD && kiezelpay_is_error_alert_displayed()) {
    kiezelpay_hide_alert();    //hide any alert that might have been shown before
  }
#endif
  kiezelpay_flags.kiezelpay_generic_errors = 0;
  if (msg->status == 2) {
    //valid license detected!
    kiezelpay_current_state.licensed = true;
    kiezelpay_store_state(msg->validity_period);
    
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    if (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress) {
#endif
      //fire the event
      if (!kiezelpay_fire_event(KIEZELPAY_LICENSED, NULL)) {
        if (kiezelpay_flags.kiezelpay_purchase_in_progress) {
          //was not handled by user, so handle it ourselves
          // ==> only if there was an actual purchase in progress, if there never was a purchase this
          //means the user deleted and reinstalled the app after previously purchasing it, 
          //no need to show the "thank you for purchasing" message in that case...
          kiezelpay_unhandled_event(KIEZELPAY_LICENSED, NULL);
          kiezelpay_flags.kiezelpay_purchase_in_progress = false;
        }
      }
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    }
#endif
    
    //stop the status checks, we're done
    kiezelpay_end_status_reached();
  }
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
  else if (msg->status == 1) {
    if (!kiezelpay_current_state.trial_ended
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
        || kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress
#endif
       ) {
      //we are in trial mode
      //calc the time at which the trial will end
      int32_t new_trial_end_time = time(NULL) + msg->trial_duration;
      
      if (!kiezelpay_current_state.trial_started || 
          kiezelpay_current_state.trial_end_time == 0 || 
          kiezelpay_current_state.trial_end_time > new_trial_end_time) {
        //update state
        kiezelpay_current_state.licensed = false;
        if (last_event == KIEZELPAY_LICENSED) {
          last_event = KIEZELPAY_NO_EVENT;
        }
        kiezelpay_current_state.trial_started = true;  
        kiezelpay_current_state.trial_end_time = new_trial_end_time;
        kiezelpay_store_state(msg->validity_period);
        
        //fire event to show trial started (or end time updated), don't care if user handles it, we dont do anything with it
        if (!kiezelpay_fire_event(KIEZELPAY_TRIAL_STARTED, &(kiezelpay_current_state.trial_end_time))) {
          kiezelpay_unhandled_event(KIEZELPAY_TRIAL_STARTED, &(kiezelpay_current_state.trial_end_time));
        }
      }
      
      //status checking is done for now, until the trial ends
      kiezelpay_end_status_reached();
  
      //start a timer that fires on end of trial
      kiezelpay_schedule_trial_end_timer();
    }
    else {
      //something wrong with this response, this app supports no trial or trial had already ended...
      LOG("Invalid trial message received!");
      kiezelpay_generic_error_occurred();
      
      //try again
      kiezelpay_failsafe_schedule_status_check(NULL);
    }
  }
#endif
  else if (msg->status == 0) {
    if (msg->purchase_code == 0 || msg->purchase_status >= 2) {
      //not valid
      kiezelpay_generic_error_occurred();
    }
    else {     
      kiezelpay_current_state.licensed = false;
      if (last_event == KIEZELPAY_LICENSED) {
        last_event = KIEZELPAY_NO_EVENT;
      }
      kiezelpay_flags.kiezelpay_purchase_in_progress = true;
      uint32_t purchase_code = msg->purchase_code;
      if (msg->purchase_status == 0) {
        //waiting for user to enter purchase code
        //fire the event
        if (!kiezelpay_fire_event(KIEZELPAY_CODE_AVAILABLE, &purchase_code)) {
          //was not handled by user, so handle it ourselves
          kiezelpay_unhandled_event(KIEZELPAY_CODE_AVAILABLE, &purchase_code);
        }
      }
      else if (msg->purchase_status == 1) {
        //user entered code and is purchasing
        if (!kiezelpay_fire_event(KIEZELPAY_PURCHASE_STARTED, &purchase_code)) {
          //was not handled by user, so handle it ourselves
          kiezelpay_unhandled_event(KIEZELPAY_PURCHASE_STARTED, &purchase_code);
        }
      }
    }
    
    //keep checking until the purchase is done
    kiezelpay_failsafe_schedule_status_check(NULL);
  }
  else {
    //unknown message... try again
    LOG("Unsupported status: %d", msg->status);
    kiezelpay_generic_error_occurred();

    //try again
    kiezelpay_failsafe_schedule_status_check(NULL);
  }
}

#if KIEZELPAY_DISABLE_MESSAGES == 0
//----------------- TIMER FUNCTIONS  -------------------//
// These functions are for SDK2 compatibility (there is no StatusBarLayer)

#ifdef PBL_SDK_2
static void kiezelpay_show_time_in_bar() {
  time_t tick_time = time(NULL);
  struct tm *ltime = localtime(&tick_time);

	if (clock_is_24h_style()) {
	  strftime(kiezelpay_time_text_buffer, sizeof(kiezelpay_time_text_buffer), "%H:%M", ltime);
	} else {
	  strftime(kiezelpay_time_text_buffer, sizeof(kiezelpay_time_text_buffer), "%I:%M", ltime);
	}

	text_layer_set_text(kiezelpay_time_text_layer, kiezelpay_time_text_buffer);
}

static void kiezelpay_handle_top_bar_time(void *data) {
  kiezelpay_show_time_in_bar();
  // Reschedule the timer
  app_timer_reschedule(kiezelpay_top_bar_timer, 60000);
}
//----------------- LAYERS UPDATE_PROC -------------------//

static void kiezelpay_top_bar_update_proc(Layer *layer, GContext *ctx) {
  graphics_context_set_fill_color(ctx, GColorBlack);
  GRect frame = layer_get_bounds(layer);
  graphics_fill_rect(ctx, frame, 0, 0);
}
#endif
  
static void kiezelpay_bottom_bar_update_proc(Layer *layer, GContext *ctx) {
  graphics_context_set_fill_color(ctx, GColorBlack);
  GRect frame = layer_get_bounds(layer);
  graphics_fill_rect(ctx, frame, 0, 0);
}

//------------------------- UTILS --------------------------//

static void kiezelpay_hide_code(bool hide){
  layer_set_hidden(kiezelpay_bottom_bar_layer, hide);
  layer_set_hidden(text_layer_get_layer(kiezelpay_bottom_text_layer), hide);
}
  
static void back_click_handler(ClickRecognizerRef recognizer, void *context) {
  LOG("Preventing Back button from closing the dialog");
}

static void config_provider(Window *window) {
  window_single_click_subscribe(BUTTON_ID_BACK, back_click_handler);
}

//----------------- WINDOW LOAD & UNLOAD -------------------//

static void kiezelpay_alert_window_load(Window *window) {
  Layer *kiezelpay_window_layer = window_get_root_layer(kiezelpay_alert_window);
  GRect bounds = layer_get_bounds(kiezelpay_window_layer);

#ifdef PBL_SDK_3
  kiezelpay_status_bar_layer = status_bar_layer_create();
  GColor bar_color = (kiezelpay_isErrorAlert) ? COLOR_FALLBACK(GColorRed,GColorBlack) : COLOR_FALLBACK(GColorMediumSpringGreen,GColorBlack);
  status_bar_layer_set_colors(kiezelpay_status_bar_layer, bar_color, GColorBlack);
  layer_add_child(kiezelpay_window_layer, status_bar_layer_get_layer(kiezelpay_status_bar_layer));
#else

  GRect time_frame = GRect(0, 0, bounds.size.w, 20);

  kiezelpay_top_bar_layer = layer_create(time_frame);
  layer_set_update_proc(kiezelpay_top_bar_layer, kiezelpay_top_bar_update_proc);
  layer_add_child(kiezelpay_window_layer, kiezelpay_top_bar_layer);

  kiezelpay_time_text_layer = text_layer_create(time_frame);
  text_layer_set_text_alignment(kiezelpay_time_text_layer, GTextAlignmentCenter);
  text_layer_set_background_color(kiezelpay_time_text_layer, GColorClear);
  text_layer_set_text_color(kiezelpay_time_text_layer, GColorWhite);
  text_layer_set_font(kiezelpay_time_text_layer, fonts_get_system_font(FONT_KEY_GOTHIC_14));
  text_layer_set_text(kiezelpay_time_text_layer, "00:00");
  layer_add_child(kiezelpay_window_layer, text_layer_get_layer(kiezelpay_time_text_layer));
#endif

  kiezelpay_message_layer = text_layer_create(PBL_IF_ROUND_ELSE(GRect(7, 36, bounds.size.w-7,90), GRect(5, 20, bounds.size.w-5,90)));
  text_layer_set_text(kiezelpay_message_layer, kiezelpay_message_text);
  text_layer_set_text_alignment(kiezelpay_message_layer, GTextAlignmentCenter);
  text_layer_set_background_color(kiezelpay_message_layer, GColorClear);
  text_layer_set_font(kiezelpay_message_layer, fonts_get_system_font(FONT_KEY_GOTHIC_18_BOLD));
  layer_add_child(kiezelpay_window_layer, text_layer_get_layer(kiezelpay_message_layer));

#if PBL_SDK_3 && !PBL_PLATFORM_APLITE
  // If SDK3 we want to use the new text flow to adapt properly to the Pebble Round
  text_layer_enable_screen_text_flow_and_paging(kiezelpay_message_layer, 2);
#endif

  GRect bottom_frame = GRect(0, 122, bounds.size.w, 36);

  kiezelpay_bottom_bar_layer = layer_create(bottom_frame);
  layer_set_update_proc(kiezelpay_bottom_bar_layer, kiezelpay_bottom_bar_update_proc);
  layer_add_child(kiezelpay_window_layer, kiezelpay_bottom_bar_layer);

  kiezelpay_bottom_text_layer = text_layer_create(bottom_frame);
  text_layer_set_text_alignment(kiezelpay_bottom_text_layer, GTextAlignmentCenter);
  text_layer_set_background_color(kiezelpay_bottom_text_layer, GColorClear);
  text_layer_set_text_color(kiezelpay_bottom_text_layer, GColorWhite);
  
  if (kiezelpay_code_text != NULL) {
    text_layer_set_text(kiezelpay_bottom_text_layer, kiezelpay_code_text);
  }
  else {
    kiezelpay_hide_code(true);
  }
#ifdef PBL_SDK_3
  text_layer_set_font(kiezelpay_bottom_text_layer, fonts_get_system_font(FONT_KEY_LECO_26_BOLD_NUMBERS_AM_PM));
#else
  text_layer_set_font(kiezelpay_bottom_text_layer, fonts_get_system_font(FONT_KEY_GOTHIC_28));
#endif
  layer_add_child(kiezelpay_window_layer, text_layer_get_layer(kiezelpay_bottom_text_layer));

#ifdef PBL_SDK_2
  layer_mark_dirty(kiezelpay_top_bar_layer);
  // start the time on the bar
  kiezelpay_show_time_in_bar();
  // Create timer to update the top bar time
  kiezelpay_top_bar_timer = app_timer_register(60000, kiezelpay_handle_top_bar_time, NULL);
#endif
}

static void kiezelpay_alert_window_unload(Window *window) {
  text_layer_destroy(kiezelpay_bottom_text_layer);
  layer_destroy(kiezelpay_bottom_bar_layer);

  text_layer_destroy(kiezelpay_message_layer);
#ifdef PBL_SDK_3
  status_bar_layer_destroy(kiezelpay_status_bar_layer);
#else
  text_layer_destroy(kiezelpay_time_text_layer);
  layer_destroy(kiezelpay_top_bar_layer);
  
  if (kiezelpay_top_bar_timer != NULL) {
    app_timer_cancel(kiezelpay_top_bar_timer);
  }
  kiezelpay_top_bar_timer = NULL;
#endif

  free(kiezelpay_message_text);
  free(kiezelpay_code_text);
}

//----------------- PUBLIC FUNCTIONS -------------------//

static void kiezelpay_show_alert(const char *message, uint32_t *code, bool isError, uint32_t auto_hide_timeout_in_seconds){
  //notify the user that a message is coming
  vibes_double_pulse();
  
  // Initialize message and code
  kiezelpay_message_text = (char*)calloc(strlen(message)+1, sizeof(char));
  strcpy(kiezelpay_message_text, message);

  if (code != NULL) {
    kiezelpay_code_text = (char*)calloc(5+1, sizeof(char));
    snprintf(kiezelpay_code_text, 6, "%05d", (int)*code);
  }

  kiezelpay_isErrorAlert = isError;

  //check if new window
 	if (kiezelpay_alert_window == NULL) {
    //create new window
 		kiezelpay_alert_window = window_create();
	  window_set_window_handlers(kiezelpay_alert_window, (WindowHandlers) {
      .load = kiezelpay_alert_window_load,
      .unload = kiezelpay_alert_window_unload,
    });
    window_set_click_config_provider(kiezelpay_alert_window, (ClickConfigProvider) config_provider);
    window_set_background_color(kiezelpay_alert_window, GColorWhite);
    window_stack_push(kiezelpay_alert_window, true);
 	}
  else {
    //window already existed, just change the text
    text_layer_set_text(kiezelpay_message_layer, kiezelpay_message_text);
    
    // Change code text
    if (code != NULL) {
      snprintf(kiezelpay_code_text, 6, "%05d", (int)*code);
      text_layer_set_text(kiezelpay_bottom_text_layer, kiezelpay_code_text);
      kiezelpay_hide_code(false);
    }
    else {
      // hide code in case it's null
      kiezelpay_hide_code(true);
    }
  
  #ifdef PBL_SDK_3
    GColor bar_color = (kiezelpay_isErrorAlert) ? COLOR_FALLBACK(GColorRed, GColorBlack) : COLOR_FALLBACK(GColorGreen, GColorBlack);
    status_bar_layer_set_colors(kiezelpay_status_bar_layer, bar_color, GColorBlack);
  #endif
  }
  
  //check if we should hide the text after a little while
  if (kiezelpay_hideMsgTimer != NULL) {
    app_timer_cancel(kiezelpay_hideMsgTimer);
    kiezelpay_hideMsgTimer = NULL;
  }
  if (auto_hide_timeout_in_seconds > 0) {
    kiezelpay_hideMsgTimer = app_timer_register(auto_hide_timeout_in_seconds * 1000, kiezelpay_hide_alert, NULL);
  }
}

static void kiezelpay_hide_alert() {
  if (kiezelpay_alert_window != NULL) {
    window_stack_remove(kiezelpay_alert_window, true);
    kiezelpay_alert_window = NULL;
  }
}
  
static bool kiezelpay_is_error_alert_displayed() {
  return (kiezelpay_alert_window != NULL) && kiezelpay_isErrorAlert;
}
#endif

static void kiezelpay_unhandled_event(kiezelpay_event e, void* extra_data) {
#if KIEZELPAY_TEST_MODE && KIEZELPAY_LOG_VERBOSE && KIEZELPAY_DISABLE_MESSAGES
  char* event_name;
  switch (e) {
    case KIEZELPAY_ERROR:
      event_name = "KIEZELPAY_ERROR";
      break;
    case KIEZELPAY_BLUETOOTH_UNAVAILABLE:
      event_name = "KIEZELPAY_BLUETOOTH_UNAVAILABLE";
      break;
    case KIEZELPAY_INTERNET_UNAVAILABLE:
      event_name = "KIEZELPAY_INTERNET_UNAVAILABLE";
      break;
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
    case KIEZELPAY_TRIAL_STARTED:
      event_name = "KIEZELPAY_TRIAL_STARTED";
      break;
#endif
    case KIEZELPAY_TRIAL_ENDED:
      event_name = "KIEZELPAY_TRIAL_ENDED";
      break;
    case KIEZELPAY_CODE_AVAILABLE:
      event_name = "KIEZELPAY_CODE_AVAILABLE";
      break;
    case KIEZELPAY_PURCHASE_STARTED:
      event_name = "KIEZELPAY_PURCHASE_STARTED";
      break;
    case KIEZELPAY_LICENSED:
      event_name = "KIEZELPAY_LICENSED";
      break;
    default:
      event_name = "UNKNOWN";
      break;
  };
#endif
#if KIEZELPAY_DISABLE_MESSAGES == 0
  //not in disabled msg mode, so lets display the correct message
  switch (e) {
    case KIEZELPAY_ERROR:
      kiezelpay_show_alert(KIEZELPAY_UNKNOWN_ERROR_MSG, NULL, true, 0);
      break;
    case KIEZELPAY_BLUETOOTH_UNAVAILABLE:
      kiezelpay_show_alert(KIEZELPAY_BLUETOOTH_UNAVAILABLE_MSG, NULL, true, 0);
      break;
    case KIEZELPAY_INTERNET_UNAVAILABLE:
      kiezelpay_show_alert(KIEZELPAY_INTERNET_UNAVAILABLE_MSG, NULL, true, 0);
      break;
    case KIEZELPAY_CODE_AVAILABLE:
      kiezelpay_show_alert(KIEZELPAY_CODE_AVAILABLE_MSG, (uint32_t *)extra_data, false, 0);
      break;
    case KIEZELPAY_PURCHASE_STARTED:
      kiezelpay_show_alert(KIEZELPAY_PURCHASE_STARTED_MSG, (uint32_t *)extra_data, false, 0);
      break;
    case KIEZELPAY_LICENSED:
      kiezelpay_show_alert(KIEZELPAY_LICENSED_MSG, NULL, false, 5);
      break;
    default:
      break;
  };
#else
  #if KIEZELPAY_TEST_MODE
  LOG("WARNING: The %s event was not handled by you, and the KiezelPay lib does not show messages to the user in KIEZELPAY_DISABLE_MESSAGES. Make sure this is the desired behaviour.", event_name);
  #endif
#endif
}

static bool kiezelpay_fire_event(kiezelpay_event e, void *extra_data) {
  LOG("%s", __func__);
  if (last_event != e) {
    last_event = e;
    
    if (kiezelpay_settings.on_kiezelpay_event != NULL) {
      //forward this event
      return kiezelpay_settings.on_kiezelpay_event(e, extra_data);
    }
    else {
      return false;  //not handled by user
    }
  }
  
  return true;      //same event as previous, so already handled
}

static void kiezelpay_inbox_dropped_handler(AppMessageResult reason, void *context) {
  LOG("%s", __func__);
  
  //forward call to anyone interested
  if (kiezelpay_settings.on_inbox_dropped != NULL) {
    kiezelpay_settings.on_inbox_dropped(reason, context);
  }
  if (!kiezelpay_flags.kiezelpay_status_checking_finished) {
    //try again, we were in the progress of checking status
    kiezelpay_failsafe_schedule_status_check(NULL);
  }
}

static void kiezelpay_outbox_failed_handler(DictionaryIterator *iterator, AppMessageResult reason, void *context) {
  LOG("%s", __func__);
  
  if (is_kiezelpay_message(iterator)) {
    //its our message
    if (kiezelpay_flags.kiezelpay_bt_failures >= KIEZELPAY_BLUETOOTH_FAILURES_THRESHOLD 
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
        && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
       ) {
      //fire the event
      if (!kiezelpay_fire_event(KIEZELPAY_BLUETOOTH_UNAVAILABLE, NULL)) {
        //was not handled by user, so handle it ourselves
        kiezelpay_unhandled_event(KIEZELPAY_BLUETOOTH_UNAVAILABLE, NULL);
      }
    }
  	else if (kiezelpay_flags.kiezelpay_bt_failures < KIEZELPAY_BLUETOOTH_FAILURES_THRESHOLD 
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0      
      && (!kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress)
#endif
    ) {
  		kiezelpay_flags.kiezelpay_bt_failures++;
  	}
   
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    if (kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress) {
      //stop status requests after one try when doing rechecks
      kiezelpay_end_status_reached();
      
      //reschedule to try again after one day
      kiezelpay_store_state(1);
    }
    else {
#endif
      //no recheck, normal status requests, try again
      kiezelpay_failsafe_schedule_status_check(NULL);
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
    }
#endif
  }
  else if (kiezelpay_settings.on_outbox_failed != NULL) {
    //forward call to anyone interested
    kiezelpay_settings.on_outbox_failed(iterator, reason, context);
  }
}

static void kiezelpay_outbox_sent_handler(DictionaryIterator *iterator, void *context) {
  LOG("%s", __func__);
  
  if (is_kiezelpay_message(iterator)) {
    //its our message
    #if KIEZELPAY_DISABLE_MESSAGES == 0
    if (kiezelpay_flags.kiezelpay_bt_failures >= KIEZELPAY_BLUETOOTH_FAILURES_THRESHOLD && kiezelpay_is_error_alert_displayed()) {
      kiezelpay_hide_alert();    //hide any alert that might have been shown before
    }
    #endif
    kiezelpay_flags.kiezelpay_bt_failures = 0;
  }
  else if (kiezelpay_settings.on_outbox_sent != NULL) {
    //forward call to anyone interested
    kiezelpay_settings.on_outbox_sent(iterator, context);
  }
}

//handler registration
void kiezelpay_register_event_handler(kiezelpay_event_handler handler) {
  kiezelpay_settings.on_kiezelpay_event = handler;
}
void kiezelpay_register_inbox_received(inbox_received_handler handler) {
  kiezelpay_settings.on_inbox_received = handler;
}
void kiezelpay_register_inbox_dropped(inbox_dropped_handler handler) {
  kiezelpay_settings.on_inbox_dropped = handler;
}
void kiezelpay_register_outbox_failed(outbox_failed_handler handler) {
  kiezelpay_settings.on_outbox_failed = handler;
}
void kiezelpay_register_outbox_sent(outbox_sent_handler handler) {
  kiezelpay_settings.on_outbox_sent = handler;
}

static void kiezelpay_generate_state_hash(uint8_t* hash_buffer) {
  SHA256_CTX ctx_current_state;
  sha256_init(&ctx_current_state);
  
  //add our current state
  sha256_update(&ctx_current_state, (uint8_t*)&(kiezelpay_current_state), sizeof(kiezelpay_current_state));
  
  //add our secret
  sha256_update(&ctx_current_state, kiezelpay_secret, 16);
  
  //generate hash
  sha256_final(&ctx_current_state, hash_buffer);
}

static void kiezelpay_store_state(uint8_t validity_period) {
  LOG("%s", __func__);
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  if (validity_period > 0) {    //0 == leave validity as is
#if KIEZELPAY_TEST_MODE
    kiezelpay_current_state.expiration_time = time(NULL) + 60;    //set the time at which this message expires
#else
    kiezelpay_current_state.expiration_time = time(NULL) + (validity_period * 86400);    //set the time at which this message expires
#endif
  }
#endif
  //store the state
  persist_write_data(KIEZELPAY_STORAGE_KEY_STATE, &kiezelpay_current_state, sizeof(kiezelpay_current_state));  
  persist_write_int(KIEZELPAY_STORAGE_KEY_STATE_VERSION, KIEZELPAY_STATE_VERSION);
  
  //generate current state hash
  uint8_t hash[SHA256_BLOCK_SIZE];
  kiezelpay_generate_state_hash(hash);
  
  //store the state hash
  persist_write_data(KIEZELPAY_STORAGE_KEY_STATE_HASH, hash, SHA256_BLOCK_SIZE);
  
#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
  //schedule a status recheck if needed
  kiezelpay_schedule_status_expired_timer();
#endif
}

static void kiezelpay_load_state() {
  LOG("%s", __func__);
  if (persist_exists(KIEZELPAY_STORAGE_KEY_STATE)) {
    persist_read_data(KIEZELPAY_STORAGE_KEY_STATE, &kiezelpay_current_state, sizeof(kiezelpay_current_state));
  }
}
  
static int32_t kiezelpay_get_stored_state_version() {
  LOG("%s", __func__);
  if (persist_exists(KIEZELPAY_STORAGE_KEY_STATE)) {
    if (!persist_exists(KIEZELPAY_STORAGE_KEY_STATE_VERSION)) {
      //version 0 (no version)
      return 0;
    }
    else {
      return persist_read_int(KIEZELPAY_STORAGE_KEY_STATE_VERSION);
    }
  }
  
  return -1;
}

static bool kiezelpay_validate_state() {
  LOG("%s", __func__);
  //generate the current hash of the state
  uint8_t hash[SHA256_BLOCK_SIZE];
  kiezelpay_generate_state_hash(hash);
  
  //get the stored hash
  if (persist_exists(KIEZELPAY_STORAGE_KEY_STATE_HASH)) {
    uint8_t stored_hash[SHA256_BLOCK_SIZE];
    persist_read_data(KIEZELPAY_STORAGE_KEY_STATE_HASH, stored_hash, SHA256_BLOCK_SIZE);
    
    return !memcmp(stored_hash, hash, SHA256_BLOCK_SIZE);
  }
  
  return false;
}

#if KIEZELPAY_DISABLE_PERIODIC_CHECKS == 0
static int32_t kiezelpay_get_state_expiration_time() {
  return kiezelpay_current_state.expiration_time;
}

static bool kiezelpay_perform_status_expired_checks() {
  return (kiezelpay_current_state.licensed 
#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
          || (kiezelpay_current_state.trial_started && !kiezelpay_current_state.trial_ended)
#endif
      );
}

static bool kiezelpay_is_state_expired() {
  if (kiezelpay_perform_status_expired_checks()) {
    //only perform re-checks during the trial or after being licensed
    return time(NULL) >= kiezelpay_get_state_expiration_time();
  }
  else {
    return false;    //never expire when online checks are turned off
  }
}

static void kiezelpay_start_expired_status_rechecks() {
  LOG("%s", __func__);
  kiezelpay_flags.kiezelpay_expired_status_recheck_in_progress = true;
  kiezelpay_status_check(NULL);
}

static void kiezelpay_schedule_status_expired_timer() {
  LOG("%s", __func__);
  if (kiezelpay_status_expired_timer != NULL) {
    app_timer_cancel(kiezelpay_status_expired_timer);
    kiezelpay_status_expired_timer = NULL;
  }
  
  if (kiezelpay_perform_status_expired_checks()) {
    if (kiezelpay_is_state_expired()) {
      //alreay expired, start the checks
      kiezelpay_start_expired_status_rechecks();
    }
    else {
      time_t now = time(NULL);
      LOG("Scheduling status expiration in %li seconds.", (kiezelpay_get_state_expiration_time() - now));
      kiezelpay_status_expired_timer = app_timer_register((kiezelpay_get_state_expiration_time() - now) * 1000, kiezelpay_start_expired_status_rechecks, NULL);
    }
  }
}
#endif
  
static bool kiezelpay_validate_msg(kiezelpay_msg_data *msg) {
	LOG("%s", __func__);
	//before checking the hash, do some sanity checks
	bool valid_format = (msg != NULL && msg->checksum != NULL);

	if (!valid_format) {
		return false;
	}
	//prepare sha-256 context
	SHA256_CTX ctx_msg_check;
	sha256_init(&ctx_msg_check);
	uint32_t int_for_bytes;
	int_for_bytes = kiezelpay_get_status_flags();
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 0, 1);
	sha256_update(&ctx_msg_check, (uint8_t*)&(kiezelpay_current_state.device_id) + 2, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 11, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 0, 1);
	int_for_bytes = msg->status;
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 9, 1);
	if (msg->status == 0) {          //unlicensed
	int_for_bytes = msg->purchase_code;
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 3, 1);
	}
	sha256_update(&ctx_msg_check, (uint8_t*)&(kiezelpay_current_state.device_id) + 0, 1);
	if (msg->status == 0) {          //unlicensed
	int_for_bytes = msg->purchase_code;
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 0, 1);
	}
	sha256_update(&ctx_msg_check, kiezelpay_secret + 7, 1);
	if (msg->status == 0) {          //unlicensed
	int_for_bytes = msg->purchase_code;
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 1, 1);
	}
	sha256_update(&ctx_msg_check, (uint8_t*)&(kiezelpay_current_state.device_id) + 3, 1);
	if (msg->status == 1 || msg->status == 2) {      //trial or licensed
	sha256_update(&ctx_msg_check, (uint8_t*)&(msg->validity_period), 1);
	}
	int_for_bytes = kiezelpay_get_status_flags();
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 2, 1);
	if (msg->status == 0) {          //unlicensed
	int_for_bytes = msg->purchase_code;
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 2, 1);
	}
	sha256_update(&ctx_msg_check, kiezelpay_secret + 6, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 14, 1);
	sha256_update(&ctx_msg_check, (uint8_t*)&(kiezelpay_current_state.device_id) + 1, 1);
	#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
	if (msg->status == 1) {      //trial
	sha256_update(&ctx_msg_check, (uint8_t*)&(msg->trial_duration) + 2, 1);
	}
	#endif
	sha256_update(&ctx_msg_check, kiezelpay_secret + 12, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 13, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 8, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 5, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 1, 1);
	#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
	if (msg->status == 1) {      //trial
	sha256_update(&ctx_msg_check, (uint8_t*)&(msg->trial_duration) + 3, 1);
	}
	#endif
	sha256_update(&ctx_msg_check, kiezelpay_secret + 4, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 2, 1);
	#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
	if (msg->status == 1) {      //trial
	sha256_update(&ctx_msg_check, (uint8_t*)&(msg->trial_duration) + 0, 1);
	}
	#endif
	sha256_update(&ctx_msg_check, kiezelpay_secret + 10, 1);
	sha256_update(&ctx_msg_check, (uint8_t*)&kiezelpay_msg_random + 0, 1);
	sha256_update(&ctx_msg_check, kiezelpay_secret + 3, 1);
	int_for_bytes = kiezelpay_get_status_flags();
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 1, 1);
	#if KIEZELPAY_DISABLE_TIME_TRIAL == 0
	if (msg->status == 1) {      //trial
	sha256_update(&ctx_msg_check, (uint8_t*)&(msg->trial_duration) + 1, 1);
	}
	#endif
	sha256_update(&ctx_msg_check, kiezelpay_secret + 15, 1);
	int_for_bytes = kiezelpay_get_status_flags();
	sha256_update(&ctx_msg_check, (uint8_t*)&int_for_bytes + 3, 1);
	sha256_update(&ctx_msg_check, (uint8_t*)&kiezelpay_msg_random + 1, 1);
	//calculate sha-256 hash
	uint8_t hash[SHA256_BLOCK_SIZE];
	sha256_final(&ctx_msg_check, hash);

	//compare this hash with the checksum returned by the server
	for (uint32_t i = 0; i < SHA256_BLOCK_SIZE; i++) {
		if (msg->checksum[i] != hash[i]) return false;
	}
	return true;
}

/*********************    SHA-256 Hashing   *************************/
/* Author:     Brad Conte (brad AT bradconte.com)                   */
/* Source:     https://github.com/B-Con/crypto-algorithms/          */
/********************************************************************/
/****************************** MACROS ******************************/
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

/**************************** VARIABLES *****************************/
static const uint32_t k[64] = {
	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

/*********************** FUNCTION DEFINITIONS ***********************/
void sha256_transform(SHA256_CTX *ctx, const uint8_t data[])
{
	uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

	for (i = 0, j = 0; i < 16; ++i, j += 4)
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];

	for (i = 0; i < 64; ++i) {
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
		t2 = EP0(a) + MAJ(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}

void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}

void sha256_update(SHA256_CTX *ctx, const uint8_t data[], size_t len)
{
	uint32_t i;

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			sha256_transform(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
}

void sha256_final(SHA256_CTX *ctx, uint8_t hash[])
{
	uint32_t i;

	i = ctx->datalen;

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	sha256_transform(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
	}
}